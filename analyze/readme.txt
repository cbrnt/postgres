PostgreSQLFetchedRowsRatio
> Andrew Khodus:
Ща расскажу)

> Andrew Khodus:
Это оч полезная метрика, это отношение строк которые были выданы приложению/пользователю по отношению к строкам, которые база данных "перелопатила"

> Andrew Khodus:
Говорит либо о seqscan либо о ооооч раздутом индексе

> Эдуард Вигерин:
ок почитаю, спасибо)

> Andrew Khodus:
Ну когда меньше 0,3, скорее всего дело в последовательных сканированиях, тупо индекс не используется или его нет

> Andrew Khodus:
А так, когда 0,5, может говорить о том, что индекс распух, т.е. в него пришло кучу апдейтов или делитов, по итогу в индексе (и таблице) кучу пустого пространства, которое процессору все равно нужно пролистывать и это увеличивает количество returned


Про отключение subsec
> Andrew Khodus:
Ну по идеи да, если есть индекс, и посгрес его не хватает, над сделать analyze tablename, чтобы убедиться, что посгресу показали на индекс, если все равно его не использует, тогда непосредственно в запрос писать enableseqscan=off; ну а там другие параметры менять такое, можно наверное, но главное не на уровне всего кластера)))
Вообще как правило seqscan из-за отсутствия индекса идет, редко другие причины

> Andrew Khodus:
Ну иногда бывает когда базу долго не обслуживали, планировщик видит, что половину индекса "дыры" и такой я лучше просканирую полностью

> Andrew Khodus:
Ну или в запросе нет ничего подходящего под индекс

> Andrew Khodus:
если это select, пишитеся explain select ... без выполнения и explain analyze с выполнением, где будет описано идет seqscan или нет) топ запросов из pg_stat_statements брать можно
SELECT substring(query, 1, 50) AS short_query,
              round(total_time::numeric, 2) AS total_time,
              calls,
              round(mean_time::numeric, 2) AS mean,
              round((100 * total_time / sum(total_time::numeric) OVER ())::numeric, 2) AS percentage_cpu
FROM  pg_stat_statements
ORDER BY total_time DESC
LIMIT 20;
